<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M·ªôt M√≥n Qu√† Nh·ªè ‚ù§Ô∏è</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&display=swap');
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            height: 100%;
            width: 100%;
        }
        canvas {
            display: block;
        }
        #page1 {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            height: 100%;
            cursor: pointer;
            transition: opacity 1s ease-out;
        }
        #page1 .letter-icon {
            font-size: 120px;
            animation: bounce 2s infinite;
        }
        #page1 .message {
            color: #fff;
            font-family: 'Dancing Script', cursive;
            font-size: 32px;
            margin-top: 20px;
        }
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {transform: translateY(0);}
            40% {transform: translateY(-30px);}
            60% {transform: translateY(-15px);}
        }
        #page2 {
            display: none;
            height: 100%;
            width: 100%;
            opacity: 0;
            transition: opacity 1.5s ease-in;
        }
    </style>
</head>
<body>

<div id="page1" onclick="showHeartPage()">
    <div class="letter-icon">üíå</div>
    <div class="message">H√£y b·∫•m v√†o b·ª©c th∆∞</div>
</div>

<div id="page2">
    </div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script> <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>

<script>
    // === H√ÄM CHUY·ªÇN TRANG ===
    function showHeartPage() {
        const page1 = document.getElementById('page1');
        const page2 = document.getElementById('page2');

        page1.style.opacity = '0';
        setTimeout(() => {
            page1.style.display = 'none';
            page2.style.display = 'block';
            setTimeout(() => {
                page2.style.opacity = '1';
                startCameraAnimation(); // G·ªåI H√ÄM HO·∫†T ·∫¢NH CAMERA
            }, 50);
        }, 1000);
    }

    // === TO√ÄN B·ªò M√É THREE.JS ===

    // === 1. C√ÄI ƒê·∫∂T C∆† B·∫¢N ===
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('page2').appendChild(renderer.domElement);
    const initialCameraZ = 45; // L∆∞u v·ªã tr√≠ ban ƒë·∫ßu
    camera.position.z = initialCameraZ;

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // === H√ÄM HO·∫†T ·∫¢NH CAMERA (PH·∫¶N M·ªöI) ===
    function startCameraAnimation() {
        controls.enabled = false; // T·∫Øt ƒëi·ªÅu khi·ªÉn chu·ªôt

        const targetPosition = { z: initialCameraZ * 2 }; // L√πi v·ªÅ sau x2
        const targetRotation = { x: Math.PI / 16, y: Math.PI / 16 }; // Xoay nh·∫π l√™n v√† sang tr√°i

        // Ho·∫°t ·∫£nh cho v·ªã tr√≠
        new TWEEN.Tween(camera.position)
            .to(targetPosition, 4000) // Th·ªùi gian 4 gi√¢y
            .easing(TWEEN.Easing.Quadratic.InOut)
            .onComplete(() => {
                controls.enabled = true; // B·∫≠t l·∫°i ƒëi·ªÅu khi·ªÉn khi xong
            })
            .start();

        // Ho·∫°t ·∫£nh cho g√≥c xoay
        new TWEEN.Tween(camera.rotation)
            .to(targetRotation, 4000)
            .easing(TWEEN.Easing.Quadratic.InOut)
            .start();
    }


    // === 2. TR√ÅI TIM 3D ===
    const heartParticles = 30000;
    const heartPositions = [];
    const heartScale = 15;
    let particlesAdded = 0;
    while (particlesAdded < heartParticles) {
        const x = (Math.random() - 0.5) * 3;
        const y = (Math.random() - 0.5) * 3;
        const z = (Math.random() - 0.5) * 3;
        const t1 = x*x + (9/4)*y*y + z*z - 1;
        if (Math.pow(t1, 3) - (x*x*z*z*z) - (9/80)*y*y*z*z*z < 0) {
            heartPositions.push(x*heartScale, y*heartScale, z*heartScale);
            particlesAdded++;
        }
    }
    const heartGeometry = new THREE.BufferGeometry();
    heartGeometry.setAttribute('position', new THREE.Float32BufferAttribute(heartPositions, 3));
    const heartMaterial = new THREE.PointsMaterial({ color: 0xff69b4, size: 0.1, transparent: true, blending: THREE.AdditiveBlending });
    const heart = new THREE.Points(heartGeometry, heartMaterial);
    heart.rotation.x = -Math.PI / 2;
    heart.position.y = -5;
    scene.add(heart);

    // === 3. D·∫¢I NG√ÇN H√Ä ===
    const galaxyGroup = new THREE.Group();
    scene.add(galaxyGroup);
    galaxyGroup.position.y = -15;

    const galaxyRadius = 28;
    const galaxyThickness = 12;
    const pixelParticlesCount = 5000;
    const pixelPositions = [];
    for (let i = 0; i < pixelParticlesCount; i++) {
        const angle = Math.random() * 2 * Math.PI;
        const radius = galaxyRadius + (Math.random() - 0.5) * galaxyThickness;
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        const y = (Math.random() - 0.5) * 4;
        pixelPositions.push(x, y, z);
    }
    const pixelGeometry = new THREE.BufferGeometry();
    pixelGeometry.setAttribute('position', new THREE.Float32BufferAttribute(pixelPositions, 3));
    const pixelMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1, transparent: true, opacity: 0.7, blending: THREE.AdditiveBlending });
    const pixelSystem = new THREE.Points(pixelGeometry, pixelMaterial);
    galaxyGroup.add(pixelSystem);

    // === 4. L·ªúI CH√öC NG·∫™U NHI√äN ===
    const fontLoader = new THREE.FontLoader();
    const messages = [
        "Ch√∫c em 20/10 vui v·∫ª üíê",
        "Linh Ng√¢n d·ªÖ th∆∞∆°ng xinh ƒë·∫πp üå∏",
        "Th∆∞∆°ng em üíû",
        "Em m√£i l√† em b√© c·ªßa anh üíñ",
        "I love you ‚ù§Ô∏è"
    ];
    const textPivots = [];

    function bendTextGeometry(geometry, radius) {
        const position = geometry.attributes.position;
        const vertex = new THREE.Vector3();
        for (let i = 0; i < position.count; i++) {
            vertex.fromBufferAttribute(position, i);
            const angle = vertex.x / radius;
            const x = Math.cos(angle) * radius;
            const z = -Math.sin(angle) * radius;
            position.setXYZ(i, x, vertex.y, z);
        }
        position.needsUpdate = true;
    }

    fontLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/fonts/gentilis_bold.typeface.json', function (font) {
        const textMaterial = new THREE.MeshBasicMaterial({ color: 0xffc0cb, transparent: true, opacity: 0 });
        messages.forEach((msg, i) => {
            const textGeo = new THREE.TextGeometry(msg, {
                font: font,
                size: 2,
                height: 0.1,
            });
            textGeo.center();

            const textOrbitRadius = galaxyRadius - 5 + Math.random() * 10;
            bendTextGeometry(textGeo, textOrbitRadius);
            const textMesh = new THREE.Mesh(textGeo, textMaterial.clone());
            textMesh.userData = {
                visibleTime: Math.random() * 3,
                delay: Math.random() * 4 + 1
            };

            const pivot = new THREE.Group();
            const randomAngle = (i / messages.length) * Math.PI * 2 + Math.random() * 0.5;
            pivot.rotation.y = randomAngle;
            pivot.position.y = -2 + Math.random() * 4;
            pivot.add(textMesh);
            textPivots.push({ pivot, mesh: textMesh });
            galaxyGroup.add(pivot);
        });
    });

    // === 5. SAO BƒÇNG NG·∫™U NHI√äN BAY T·ª™ TR√ÅI QUA PH·∫¢I ===
    const shootingStars = [];

    function createShootingStar() {
        const startX = -60 + Math.random() * 20;
        const startY = Math.random() * 40 - 10;
        const startZ = Math.random() * 40 - 20;
        const velocityX = 25;
        const velocityY = -2 - Math.random() * 2;
        const velocityZ = -2 + Math.random() * 4;
        const star = {
            position: new THREE.Vector3(startX, startY, startZ),
            velocity: new THREE.Vector3(velocityX, velocityY, velocityZ),
            life: 0, duration: 4, trail: [], points: null
        };
        const geometry = new THREE.BufferGeometry();
        const material = new THREE.PointsMaterial({
            color: 0x87cefa, size: 0.25, transparent: true,
            opacity: 1, blending: THREE.AdditiveBlending
        });
        geometry.setAttribute('position', new THREE.Float32BufferAttribute([], 3));
        star.points = new THREE.Points(geometry, material);
        scene.add(star.points);
        shootingStars.push(star);
    }

    // === 7. M∆ØA H·∫†T S√ÅNG ===
    const rainCount = 80000;
    const rainPositions = [];
    const rainVelocities = [];
    const rainBounds = { x: 150, y: 100, z: 150 };
    for (let i = 0; i < rainCount; i++) {
        rainPositions.push(
            (Math.random() - 0.5) * rainBounds.x,
            (Math.random() - 0.5) * rainBounds.y,
            (Math.random() - 0.5) * rainBounds.z
        );
        rainVelocities.push(2 + Math.random() * 3);
    }
    const rainGeometry = new THREE.BufferGeometry();
    rainGeometry.setAttribute('position', new THREE.Float32BufferAttribute(rainPositions, 3));
    const rainMaterial = new THREE.PointsMaterial({
        color: 0xcccccc, size: 0.08, transparent: true,
        opacity: 0.6, blending: THREE.AdditiveBlending
    });
    const rain = new THREE.Points(rainGeometry, rainMaterial);
    scene.add(rain);

    // === 6. HO·∫†T ·∫¢NH ===
    const clock = new THREE.Clock();
    const baseParticleSize = 0.1, pulseSpeed = 2.0, pulseAmplitude = 0.05;

    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        const elapsed = clock.getElapsedTime();

        TWEEN.update(); // C·∫¨P NH·∫¨T HO·∫†T ·∫¢NH TWEEN

        // Tim ƒë·∫≠p
        const pulse = (Math.sin(elapsed * pulseSpeed) + 1) / 2;
        heartMaterial.size = baseParticleSize + pulse * pulseAmplitude;
        heartMaterial.opacity = 0.5 + ((Math.sin(elapsed * 2) + 1) / 2) * 0.5;
        heart.position.z = Math.sin(elapsed * 1.2) * 3;
        galaxyGroup.rotation.y += delta * 0.15;

        // L·ªùi ch√∫c
        textPivots.forEach(({ mesh }) => {
            mesh.userData.visibleTime += delta;
            const cycle = 5;
            const t = mesh.userData.visibleTime % (cycle + mesh.userData.delay);
            if (t < 1) mesh.material.opacity = t;
            else if (t < 4) mesh.material.opacity = 1;
            else if (t < 5) mesh.material.opacity = 1 - (t - 4);
            else mesh.material.opacity = 0;
        });
        
        // M∆∞a r∆°i
        const rainPosArray = rain.geometry.attributes.position.array;
        for (let i = 0; i < rainCount; i++) {
            const yIndex = i * 3 + 1;
            const speed = rainVelocities[i];
            rainPosArray[yIndex] -= speed * delta;
            if (rainPosArray[yIndex] < -rainBounds.y / 2) {
                rainPosArray[yIndex] = rainBounds.y / 2;
            }
        }
        rain.geometry.attributes.position.needsUpdate = true;

        // Sao bƒÉng
        if (Math.random() < 0.025) createShootingStar();
        for (let i = shootingStars.length - 1; i >= 0; i--) {
            const star = shootingStars[i];
            star.life += delta;
            if (star.life > 2) star.velocity.multiplyScalar(0.96);
            star.position.addScaledVector(star.velocity, delta);
            star.trail.unshift(star.position.clone());
            const maxTrail = 40;
            let currentTrailLength = Math.max(1, Math.floor(maxTrail * Math.max(0, 1 - (star.life - 2) / 2)));
            if (star.trail.length > currentTrailLength) star.trail.pop();
            const trailPositions = [];
            star.trail.forEach(p => trailPositions.push(p.x, p.y, p.z));
            star.points.geometry.setAttribute('position', new THREE.Float32BufferAttribute(trailPositions, 3));
            star.points.geometry.attributes.position.needsUpdate = true;
            star.points.material.opacity = Math.max(0, 1 - (star.life - 2) / 2);
            if (star.life > star.duration) {
                scene.remove(star.points);
                shootingStars.splice(i, 1);
            }
        }

        controls.update();
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>